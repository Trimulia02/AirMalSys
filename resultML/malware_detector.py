import json
import torch
import torch.nn as nn
import pickle
from typing import Dict
import os

class MalwareBiLSTM(nn.Module):
    def __init__(self, vocab_size, embedding_dim=64, hidden_dim=128, num_layers=2, num_features=4, dropout=0.3):
        super().__init__()
        self.embedding = nn.Embedding(vocab_size, embedding_dim, padding_idx=0)
        self.lstm = nn.LSTM(embedding_dim, hidden_dim, num_layers, batch_first=True, bidirectional=True, dropout=dropout)
        self.fc_sequence = nn.Linear(hidden_dim * 2, 64)
        self.fc_numeric = nn.Linear(num_features, 32)
        self.fc_combined = nn.Linear(64 + 32, 32)
        self.fc_output = nn.Linear(32, 1)
        self.dropout = nn.Dropout(dropout)
        
    def forward(self, sequence, numeric):
        embedded = self.embedding(sequence)
        lstm_out, _ = self.lstm(embedded)
        sequence_features = torch.mean(lstm_out, dim=1)
        sequence_features = self.fc_sequence(sequence_features)
        
        numeric_features = self.fc_numeric(numeric)
        combined = torch.cat([sequence_features, numeric_features], dim=1)
        combined = self.dropout(combined)
        combined = torch.relu(self.fc_combined(combined))
        output = self.fc_output(combined)
        return output

class SimpleMalwareDetector:
    def __init__(self, model_path='malware_model.pth', scaler_path='malware_scaler.pkl', 
                 vocab_path='malware_vocab.pkl', config_path='malware_config.json'):
        """Inisialisasi model dan load semua data pendukung."""
        self.device = torch.device('cuda' if torch.cuda.is_available() else 'cpu')

        base_dir = os.path.dirname(os.path.abspath(__file__))

        model_path = os.path.join(base_dir, model_path)
        scaler_path = os.path.join(base_dir, scaler_path)
        vocab_path = os.path.join(base_dir, vocab_path)
        config_path = os.path.join(base_dir, config_path)

        with open(config_path, 'r') as f:
            config = json.load(f)

        self.model = MalwareBiLSTM(config['vocab_size']).to(self.device)
        self.model.load_state_dict(torch.load(model_path, map_location=self.device))
        self.model.eval()

        with open(scaler_path, 'rb') as f:
            self.scaler = pickle.load(f)

        with open(vocab_path, 'rb') as f:
            vocab_data = pickle.load(f)
            self.process_vocab = vocab_data['process_vocab']
            self.path_vocab = vocab_data['path_vocab']

        self.threshold = config['optimal_threshold']

    def predict(self, report_json_path: str) -> str:
        """Prediksi label dari report.json Cuckoo: MALWARE atau BENIGN."""
        with open(report_json_path, 'r') as f:
            r = json.load(f)

        procs, paths = [], []
        for sig in r.get("signatures", []):
            if sig.get("name", "") == "executes_dropped_exe":
                for entry in sig.get("iocs", {}).get("iocs", []):
                    i = entry.get("ioc", {})
                    if i.get("process"):
                        procs.append(i["process"])
                    if i.get("path"):
                        paths.append(i["path"])

        net = r.get("network", {})
        features = {
            'exec_processes': ";".join(procs),
            'exec_paths': ";".join(paths),
            'num_execs': len(procs),
            'num_unique_execs': len(set(procs)),
            'num_dns_queries': len(net.get("dns", {}).get("query", [])),
            'num_udp_packets': len(net.get("udp", []))
        }

        def text_to_sequence(text, vocab, max_len=100):
            if not text:
                return [0] * max_len
            tokens = text.split(';')[:max_len]
            sequence = [vocab.get(token, 1) for token in tokens]
            return sequence + [0] * (max_len - len(sequence))

        process_seq = text_to_sequence(features['exec_processes'], self.process_vocab)
        path_seq = text_to_sequence(features['exec_paths'], self.path_vocab)
        combined_seq = process_seq + path_seq

        numeric_data = [[
            features['num_execs'],
            features['num_unique_execs'], 
            features['num_dns_queries'],
            features['num_udp_packets']
        ]]
        numeric_scaled = self.scaler.transform(numeric_data)

        sequence_tensor = torch.tensor([combined_seq], dtype=torch.long).to(self.device)
        numeric_tensor = torch.tensor(numeric_scaled, dtype=torch.float32).to(self.device)

        with torch.no_grad():
            output = self.model(sequence_tensor, numeric_tensor)
            probability = torch.sigmoid(output).cpu().numpy()[0][0]

        return "MALWARE" if probability > self.threshold else "BENIGN"

# CLI usage
if __name__ == "__main__":
    import sys

    if len(sys.argv) != 2:
        print("Usage: python malware_detector.py <report.json>")
        sys.exit(1)

    report_file = sys.argv[1]
    try:
        detector = SimpleMalwareDetector()
        result = detector.predict(report_file)
        print(result)

        # âœ… Simpan ke Logs/ml_results.txt
        logs_path = os.path.join(os.path.dirname(os.path.abspath(__file__)), '..', 'Logs', 'ml_results.txt')
        logs_path = os.path.abspath(logs_path)
        os.makedirs(os.path.dirname(logs_path), exist_ok=True)
        with open(logs_path, 'w') as f:
            f.write(f"Predicted family: {result.lower()}\n")

    except Exception as e:
        print(f"ERROR: {e}")
        sys.exit(1)
